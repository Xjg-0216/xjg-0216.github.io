多线程（Multithreading）是指在一个进程（Process）中同时执行多个线程（Thread），以实现并发处理任务，从而提高程序的执行效率，特别适合处理**IO密集型或部分CPU密集型**任务。

---

## 一、线程 vs 进程

| 比较项  | 进程（Process）        | 线程（Thread）       |
| ---- | ------------------ | ---------------- |
| 定义   | 资源分配的基本单位          | CPU调度的基本单位       |
| 拥有资源 | 独立的内存空间等资源         | 与同一进程中的其他线程共享资源  |
| 通信开销 | 进程间通信（如管道、消息队列）较复杂 | 线程间通信简单，因共享内存    |
| 创建销毁 | 开销大                | 开销小              |
| 崩溃影响 | 一个进程崩溃不影响其他进程      | 一个线程崩溃可能导致整个进程崩溃 |

---

## 二、为什么要使用多线程？

1. **提升程序响应性**（如图形界面不卡顿）
2. **提高CPU利用率**（特别是多核CPU）
3. **任务并行处理**（如下载+解码+播放视频）
4. **更好地处理IO密集型任务**（等待时间可用于做别的事）

---

## 三、常见的使用场景

* 图像处理（并行滤波）
* 文件下载（多线程分段）
* 网络服务器（一个连接一个线程）
* 游戏引擎（渲染/物理/AI分别独立线程）

---

## 四、C++多线程（以 C++11 为例）

### 引入头文件：

```cpp
#include <thread>
```

### 基本使用：

```cpp
#include <iostream>
#include <thread>

void task() {
    std::cout << "线程ID: " << std::this_thread::get_id() << "\n";
}

int main() {
    std::thread t(task);  // 创建线程
    t.join();             // 等待线程执行完成
    return 0;
}
```

---

## 五、线程常用方法

| 方法                              | 说明                |
| ------------------------------- | ----------------- |
| `join()`                        | 阻塞主线程，等待该线程完成     |
| `detach()`                      | 线程脱离，后台运行，主线程无需等待 |
| `std::this_thread::sleep_for()` | 当前线程睡眠一段时间        |
| `std::this_thread::get_id()`    | 获取当前线程ID          |

---

## 六、线程安全与同步

多线程之间**共享资源**可能导致数据竞争（data race）和**不确定行为**，为此需引入**同步机制**：

### 常见同步工具

| 工具                        | 作用                 |
| ------------------------- | ------------------ |
| `std::mutex`              | 互斥锁，防止多个线程同时访问同一资源 |
| `std::lock_guard`         | 自动加锁解锁，RAII风格      |
| `std::unique_lock`        | 更灵活的锁管理            |
| `std::condition_variable` | 条件变量，用于线程等待和唤醒     |

### 示例（互斥锁）：

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;

void print_safe(int id) {
    std::lock_guard<std::mutex> lock(mtx);
    std::cout << "线程 " << id << " 正在打印\n";
}

int main() {
    std::thread t1(print_safe, 1);
    std::thread t2(print_safe, 2);
    t1.join();
    t2.join();
    return 0;
}
```

---

## 七、线程池（高级）

如果你频繁地创建和销毁线程，会带来性能开销，因此可以使用**线程池**（Thread Pool）：

* 预先创建一批线程
* 用任务队列分配任务
* 提高资源复用效率

C++标准库没有内置线程池，但可以使用：

* `boost::asio::thread_pool`
* `ThreadPool` 自定义类（GitHub上很多）
* `std::async`（轻量的并发任务）

---

## 八、注意事项

* 不要轻易使用 `detach()`，容易造成资源悬挂
* 保证访问共享资源时加锁，避免数据竞争
* 线程间通信需小心死锁、饥饿等问题
* 善用RAII（如 `lock_guard`）防止忘记解锁
