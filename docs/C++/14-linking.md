
# 静态编译和动态编译


静态编译和动态编译是两种常见的程序编译与链接方式，它们的核心区别在于**代码如何与库进行链接、依赖库如何加载**。以下是两者的**区别与联系**：


## 1. 区别

| 方面       | 静态编译（Static Linking）   | 动态编译（Dynamic Linking）            |
| -------- | ---------------------- | -------------------------------- |
| **链接时间** | 在编译期间就将所有依赖的库链接到可执行文件中 | 在程序运行时再加载动态库（如 `.so`, `.dll` 文件） |
| **文件体积** | 生成的可执行文件较大，库代码已经打包进去   | 可执行文件较小，库代码不包含在内                 |
| **运行依赖** | 无需依赖外部库，独立运行           | 需要依赖系统中存在对应的动态库                  |
| **升级维护** | 更新库需要重新编译整个程序          | 动态库升级后可不需重新编译程序                  |
| **加载效率** | 启动速度较快（无加载过程）          | 启动时要加载库，略慢一点                     |
| **占用内存** | 多个程序各自占用一份库的内存         | 多个程序可共享一份动态库内存，提高系统资源利用效率        |
| **移植性**  | 更好，打包时已经包含所有依赖         | 差一些，运行环境需要配置好对应的动态库              |


### 1.1 静态链接：每个程序自己占一份库的内存
编译时，将库代码 **复制进可执行文件（.exe/.out）** 中。
每个进程运行时，都有自己的那一份库代码和数据。

假设有一个程序 A 和一个程序 B 都使用 libmath.a（静态库），编译时：
```cpp
gcc a.c libmath.a -o progA
gcc b.c libmath.a -o progB
```
结果是 `progA` 和 `progB` 都各自将 `libmath` 的代码复制了一份
运行时，A 占用 1 份 `libmath` 代码段，B 也占用 1 份 —— 两份内存。

### 1.2 动态链接：多个程序共享一份库的内存

编译时只记录“需要的库函数符号”，不复制代码。

程序运行时，操作系统的 **动态链接器（如 Linux 的 ld.so)** 负责加载 .so（或 .dll）文件。

所有进程可以共享同一个库文件的内存映射。
假设 progA 和 progB 都使用 libmath.so（动态库）：
```cpp
gcc a.c -lmath -o progA
gcc b.c -lmath -o progB
```
运行两个程序后，系统发现 `libmath.so` 已经被加载了一次，于是第二个程序会复用已加载的内存地址。


## 2. 联系

1. **目的相同**：都是为了将源代码编译为可执行文件或库文件，让程序能够正常运行。
2. **编译流程类似**：都是经过预处理、编译、汇编、链接这几个步骤；
3. **可以混合使用**：一个程序可以部分使用静态库，部分使用动态库。
4. **由链接器控制行为**：开发者可以通过编译参数决定是使用 `静态链接` 还是 `动态链接`，如：

   ```bash
   gcc main.c -static -o main   # 强制使用静态链接
   gcc main.c -o main           # 默认优先动态链接
   ```


## 3. 实际应用对比

| 场景         | 推荐使用方式 | 原因                  |
| ---------- | ------ | ------------------- |
| 嵌入式/跨平台部署  | 静态编译   | 可移植性强，依赖打包在一起       |
| 桌面/服务器程序   | 动态编译   | 节省空间，便于维护升级         |
| 性能敏感/启动快需求 | 静态编译   | 不需要运行时加载库           |
| 安全更新频繁的库   | 动态编译   | 只需更新库文件即可，无需重新编译主程序 |

